
timer_set()
{
	if [ -z "$prompt_timer_begin" ]
	then
		prompt_timer_begin="$(date +"%s %N")"
	fi
}

timer_calculate()
{
	# Read the last set time
	read begin_s begin_ns <<< "$prompt_timer_begin"

	# PENDING - date takes about 11ms
	# Perhaps could do better by digging in /proc/$$.  
	read end_s end_ns <<< $(date +"%s %N")

	# The nanoseconds sometimes come up with a leading 0
	# which makes bash thinks its in base-10
	# convert these numbers for bash
	begin_ns=$((10#${begin_ns}))
	end_ns=$((10#${end_ns}))

	local s=$((end_s - begin_s))
	local ms
	if [ $end_ns -ge $begin_ns ]
	then
		ms=$(((end_ns - begin_ns) / 1000000))
	else
		s=$((s - 1))
		ms=$(((1000000000 + end_ns - begin_ns) / 1000000))
	fi
	PS1_timer="$(printf "%u.%03u" $s $ms)"
	if [ "$s" -ge 60 ]
	then
		PS1_timer="$PS1_timer [$(timer_format $s)]"
	fi
}

timer_format()
{
	local s=$1
	local days=$((s / (60*60*24)))
	s=$((s - days*60*60*24))
	local hours=$((s / (60*60)))
	s=$((s - hours*60*60))
	local min=$((s / 60))
	if [ "$days" != 0 ]
	then
		local day_string="${days}d "
	fi
	printf "$day_string%02d:%02d\n" $hours $min
}  

timer_prompt()
{
	status=$?
	local size=16
	timer_calculate
	prompt_timer_begin=
}

timer_set
PS1="\[\e[1;33m\]\$PS1_timer $PS1"
trap timer_set DEBUG
PROMPT_COMMAND="$PROMPT_COMMAND timer_prompt;"
